import * as prismic from '@prismicio/client';
import React, { useEffect } from 'react';
import { PrismicToolbar } from '@prismicio/react';
import { useRouter } from 'next/router';

function setPreviewData({ req, res }) {
  const ref = req.query.token || req.cookies[prismic.cookie.preview];
  if (ref) {
    res.setPreviewData({ ref });
  }
}

function exitPreview(config) {
  const { req } = config;
  config.res.clearPreviewData();
  if (req.headers.referer) {
    const url = new URL(req.headers.referer);
    if (url.pathname !== "/api/exit-preview") {
      config.res.redirect(req.headers.referer);
      return;
    }
  }
  config.res.redirect("/");
}

const readValue = (value) => {
  return value.replace(/%3B/g, ";");
};
const parse = (cookieString) => {
  const result = {};
  const cookies = cookieString.split("; ");
  for (const cookie of cookies) {
    const parts = cookie.split("=");
    const value = parts.slice(1).join("=");
    const name = readValue(parts[0]).replace(/%3D/g, "=");
    result[name] = readValue(value);
  }
  return result;
};
const getAll = (cookieStore) => parse(cookieStore);
const getCookie = (name, cookieStore) => getAll(cookieStore)[name];

const extractFirstSubdomain = (host) => host.split(".")[0];
const extractRepositoryNameFromObjectRef = (previewRef) => {
  try {
    const parsed = JSON.parse(decodeURIComponent(previewRef));
    const keys = Object.keys(parsed);
    const domainKey = keys.find((key) => /\.prismic\.io$/.test(key));
    if (domainKey) {
      return extractFirstSubdomain(domainKey);
    } else {
      return void 0;
    }
  } catch (e) {
    return void 0;
  }
};
const extractRepositoryNameFromURLRef = (previewRef) => {
  try {
    const url = new URL(previewRef);
    return extractFirstSubdomain(url.host);
  } catch (e) {
    return void 0;
  }
};
const extractPreviewRefRepositoryName = (previewRef) => {
  return extractRepositoryNameFromObjectRef(previewRef) || extractRepositoryNameFromURLRef(previewRef);
};

const isPrismicUpdateToolbarEvent = (event) => {
  return "detail" in event && typeof event.detail.ref === "string";
};
function PrismicPreview({
  repositoryName,
  children,
  updatePreviewURL = "/api/preview",
  exitPreviewURL = "/api/exit-preview"
}) {
  const router = useRouter();
  useEffect(() => {
    const previewRefRepositoryName = extractPreviewRefRepositoryName(getCookie("io.prismic.preview", globalThis.document.cookie));
    const startPreviewIfLoadedFromSharedLink = async () => {
      if (previewRefRepositoryName === repositoryName && !router.isPreview) {
        await fetch(updatePreviewURL);
        window.location.reload();
      }
    };
    startPreviewIfLoadedFromSharedLink();
    const handlePrismicPreviewUpdate = async (event) => {
      if (isPrismicUpdateToolbarEvent(event)) {
        event.preventDefault();
        await fetch(updatePreviewURL);
        window.location.reload();
      }
    };
    const handlePrismicPreviewEnd = async (event) => {
      event.preventDefault();
      await fetch(exitPreviewURL);
      window.location.reload();
    };
    if (window) {
      window.addEventListener("prismicPreviewUpdate", handlePrismicPreviewUpdate);
      window.addEventListener("prismicPreviewEnd", handlePrismicPreviewEnd);
    }
    return () => {
      if (window) {
        window.removeEventListener("prismicPreviewUpdate", handlePrismicPreviewUpdate);
        window.removeEventListener("prismicPreviewEnd", handlePrismicPreviewEnd);
      }
    };
  }, []);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(PrismicToolbar, {
    repositoryName
  }), children);
}

const isPrismicNextPreviewData = (previewData) => {
  return typeof previewData === "object" && "ref" in previewData;
};
const enableAutoPreviews = (config) => {
  if ("previewData" in config && config.previewData) {
    const { previewData } = config;
    if (isPrismicNextPreviewData(previewData) && previewData.ref) {
      config.client.queryContentFromRef(previewData.ref);
    }
  } else if ("req" in config && config.req) {
    config.client.enableAutoPreviewsFromReq(config.req);
  }
};

const isPrismicNextQuery = (query) => typeof query.documentId === "string" && typeof query.token === "string";
async function redirectToPreviewURL({
  req,
  res,
  client,
  linkResolver,
  defaultURL = "/"
}) {
  if (isPrismicNextQuery(req.query)) {
    const { documentId, token } = req.query;
    const previewUrl = await client.resolvePreviewURL({
      linkResolver,
      defaultURL,
      documentID: documentId,
      previewToken: token
    });
    res.redirect(previewUrl);
    return;
  }
  res.redirect(defaultURL);
}

export { PrismicPreview, enableAutoPreviews, exitPreview, redirectToPreviewURL, setPreviewData };
