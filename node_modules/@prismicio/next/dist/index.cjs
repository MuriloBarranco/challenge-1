'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const prismic = require('@prismicio/client');
const React = require('react');
const react = require('@prismicio/react');
const router = require('next/router');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
	if (e && e.__esModule) return e;
	const n = Object.create(null);
	if (e) {
		for (const k in e) {
			if (k !== 'default') {
				const d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		}
	}
	n["default"] = e;
	return Object.freeze(n);
}

const prismic__namespace = /*#__PURE__*/_interopNamespace(prismic);
const React__default = /*#__PURE__*/_interopDefaultLegacy(React);

function setPreviewData({ req, res }) {
  const ref = req.query.token || req.cookies[prismic__namespace.cookie.preview];
  if (ref) {
    res.setPreviewData({ ref });
  }
}

function exitPreview(config) {
  const { req } = config;
  config.res.clearPreviewData();
  if (req.headers.referer) {
    const url = new URL(req.headers.referer);
    if (url.pathname !== "/api/exit-preview") {
      config.res.redirect(req.headers.referer);
      return;
    }
  }
  config.res.redirect("/");
}

const readValue = (value) => {
  return value.replace(/%3B/g, ";");
};
const parse = (cookieString) => {
  const result = {};
  const cookies = cookieString.split("; ");
  for (const cookie of cookies) {
    const parts = cookie.split("=");
    const value = parts.slice(1).join("=");
    const name = readValue(parts[0]).replace(/%3D/g, "=");
    result[name] = readValue(value);
  }
  return result;
};
const getAll = (cookieStore) => parse(cookieStore);
const getCookie = (name, cookieStore) => getAll(cookieStore)[name];

const extractFirstSubdomain = (host) => host.split(".")[0];
const extractRepositoryNameFromObjectRef = (previewRef) => {
  try {
    const parsed = JSON.parse(decodeURIComponent(previewRef));
    const keys = Object.keys(parsed);
    const domainKey = keys.find((key) => /\.prismic\.io$/.test(key));
    if (domainKey) {
      return extractFirstSubdomain(domainKey);
    } else {
      return void 0;
    }
  } catch (e) {
    return void 0;
  }
};
const extractRepositoryNameFromURLRef = (previewRef) => {
  try {
    const url = new URL(previewRef);
    return extractFirstSubdomain(url.host);
  } catch (e) {
    return void 0;
  }
};
const extractPreviewRefRepositoryName = (previewRef) => {
  return extractRepositoryNameFromObjectRef(previewRef) || extractRepositoryNameFromURLRef(previewRef);
};

const isPrismicUpdateToolbarEvent = (event) => {
  return "detail" in event && typeof event.detail.ref === "string";
};
function PrismicPreview({
  repositoryName,
  children,
  updatePreviewURL = "/api/preview",
  exitPreviewURL = "/api/exit-preview"
}) {
  const router$1 = router.useRouter();
  React.useEffect(() => {
    const previewRefRepositoryName = extractPreviewRefRepositoryName(getCookie("io.prismic.preview", globalThis.document.cookie));
    const startPreviewIfLoadedFromSharedLink = async () => {
      if (previewRefRepositoryName === repositoryName && !router$1.isPreview) {
        await fetch(updatePreviewURL);
        window.location.reload();
      }
    };
    startPreviewIfLoadedFromSharedLink();
    const handlePrismicPreviewUpdate = async (event) => {
      if (isPrismicUpdateToolbarEvent(event)) {
        event.preventDefault();
        await fetch(updatePreviewURL);
        window.location.reload();
      }
    };
    const handlePrismicPreviewEnd = async (event) => {
      event.preventDefault();
      await fetch(exitPreviewURL);
      window.location.reload();
    };
    if (window) {
      window.addEventListener("prismicPreviewUpdate", handlePrismicPreviewUpdate);
      window.addEventListener("prismicPreviewEnd", handlePrismicPreviewEnd);
    }
    return () => {
      if (window) {
        window.removeEventListener("prismicPreviewUpdate", handlePrismicPreviewUpdate);
        window.removeEventListener("prismicPreviewEnd", handlePrismicPreviewEnd);
      }
    };
  }, []);
  return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, /* @__PURE__ */ React__default["default"].createElement(react.PrismicToolbar, {
    repositoryName
  }), children);
}

const isPrismicNextPreviewData = (previewData) => {
  return typeof previewData === "object" && "ref" in previewData;
};
const enableAutoPreviews = (config) => {
  if ("previewData" in config && config.previewData) {
    const { previewData } = config;
    if (isPrismicNextPreviewData(previewData) && previewData.ref) {
      config.client.queryContentFromRef(previewData.ref);
    }
  } else if ("req" in config && config.req) {
    config.client.enableAutoPreviewsFromReq(config.req);
  }
};

const isPrismicNextQuery = (query) => typeof query.documentId === "string" && typeof query.token === "string";
async function redirectToPreviewURL({
  req,
  res,
  client,
  linkResolver,
  defaultURL = "/"
}) {
  if (isPrismicNextQuery(req.query)) {
    const { documentId, token } = req.query;
    const previewUrl = await client.resolvePreviewURL({
      linkResolver,
      defaultURL,
      documentID: documentId,
      previewToken: token
    });
    res.redirect(previewUrl);
    return;
  }
  res.redirect(defaultURL);
}

exports.PrismicPreview = PrismicPreview;
exports.enableAutoPreviews = enableAutoPreviews;
exports.exitPreview = exitPreview;
exports.redirectToPreviewURL = redirectToPreviewURL;
exports.setPreviewData = setPreviewData;
